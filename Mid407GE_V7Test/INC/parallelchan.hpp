//----------------------------------------------------------------------------------------------------
#ifndef __PCHAN_HPP
    #define __PCHAN_HPP
    
#include    "main.h"
#include    "rtx_can.h"
//----------------------------------------------------------------------------------------------------
//C++类定义
//-------------------------------------------------------
#ifdef      _IN_PCHAN_CPP
    #define     pchan_ext   
#else
    #define     pchan_ext   extern
#endif
//----------------------------------------------------------------------------------------------------
//  并联相关结构
//----------------------------------------------------------------------------------------------------
//通道检索电源单元（CAN地址-1）表  --- 如果有并联，通道需要检索并联机器CAN地址
//14-0609   支持到256个通道
//15-0925   限制通道128个
//16-0129   固定并联数，调整并联检索表，不再保存到存储芯片；修改设备信息时须更新此表

typedef struct  _strNodeTbl_ // 
{
    U32     Mark;
    U8      lead_node[MAX_CHAN_NUM];    // 并联通道主节点索引（并联首节点，会超出max_chan_num，应用中须限定！！！）
    U8      obj_pchan[MAX_NODE_NUM];    // 节点映射并联通道（索引为节点号，数值为并联通道号，128个节点，允许越界，越界部分不访问）
    U16     node_num;                   // 实际控制总节点数（与下位机通信限制用）
    U16     crc;

}   strNodeTbl;

//typedef struct  _strChSearch_ // 2320bytes
//{
//    U32   Mark;
//    U32   rev1;
//    U8    unit_num[MAX_CHAN_NUM];     // 通道并联数
//    U8    unit_master[MAX_CHAN_NUM];  // 通道主机号
//    
////15-1113   限制通道96个
////    U32   unit_img0[MAX_CHAN_NUM];    // 通道并联表0
////    U32   unit_img1[MAX_CHAN_NUM];    // 通道并联表1
////    U32   unit_img2[MAX_CHAN_NUM];    // 通道并联表2
//    
//    U64   unit_img0[MAX_CHAN_NUM];    // 通道并联表0
//    U64   unit_img1[MAX_CHAN_NUM];    // 通道并联表1

//    U32   rev2;
//    U16   rev3;
//    U16   crc;

//}   strChSearch;
//------------------------------------------------------------
//保存CAN接收的实时数据 16-0708 电流电压有符号
//typedef struct  _strCanRxData_
//{
//    U32     Cur;
//    U32     Vol;
//    U32     Stat;

//}   strCanRxData;
typedef struct  _strCanRxData_
{
    S32     Cur;
    S32     Vol;
    U32     Stat;

}   strCanRxData;
//------------------------------------------------------------
const U32 B32MSK_TBL[32] = 
{
    0x00000001,0x00000002,0x00000004,0x00000008,0x00000010,0x00000020,0x00000040,0x00000080,
    0x00000100,0x00000200,0x00000400,0x00000800,0x00001000,0x00002000,0x00004000,0x00008000,
    0x00010000,0x00020000,0x00040000,0x00080000,0x00100000,0x00200000,0x00400000,0x00800000,
    0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000
};
//------------------------------------------------------------
const U64 B64MSK_TBL[64] = 
{
    0x0000000000000001,0x0000000000000002,0x0000000000000004,0x0000000000000008,0x0000000000000010,0x0000000000000020,0x0000000000000040,0x0000000000000080,
    0x0000000000000100,0x0000000000000200,0x0000000000000400,0x0000000000000800,0x0000000000001000,0x0000000000002000,0x0000000000004000,0x0000000000008000,
    0x0000000000010000,0x0000000000020000,0x0000000000040000,0x0000000000080000,0x0000000000100000,0x0000000000200000,0x0000000000400000,0x0000000000800000,
    0x0000000001000000,0x0000000002000000,0x0000000004000000,0x0000000008000000,0x0000000010000000,0x0000000020000000,0x0000000040000000,0x0000000080000000,
    0x0000000100000000,0x0000000200000000,0x0000000400000000,0x0000000800000000,0x0000001000000000,0x0000002000000000,0x0000004000000000,0x0000008000000000,
    0x0000010000000000,0x0000020000000000,0x0000040000000000,0x0000080000000000,0x0000100000000000,0x0000200000000000,0x0000400000000000,0x0000800000000000,
    0x0001000000000000,0x0002000000000000,0x0004000000000000,0x0008000000000000,0x0010000000000000,0x0020000000000000,0x0040000000000000,0x0080000000000000,
    0x0100000000000000,0x0200000000000000,0x0400000000000000,0x0800000000000000,0x1000000000000000,0x2000000000000000,0x4000000000000000,0x8000000000000000
};
//----------------------------------------------------------------------------------------------------
#ifdef  __cplusplus
//----------------------------------------------------------------------------------------------------
//类结构定义
//----------------------------------------------------------------------------------------------------
//定义测试机并联通道类
/*
    并联通道提供物理CAN同实际通道（含并联）的映射关系，通过并联类整合CAN数据到通道，同时分配控制值到CAN

    这里没有主机的概念。

    可以是 一对一（一个CAN对一个通道）映射 -- （非并联）
        和 多对一（多个CAN对一个通道）映射 -- （并联）
*/
//----------------------------------------------------------------------------------------------------
class ParallelChan //: public Chan
{
//变量
private:
//  U8              mAddr;                      // 测试机子地址
    U8              mCanFrameNo;                // CAN数据帧标记
    U8              mFrameIndex;

    U8              mConnection[MAX_NODE_NUM];  // 联机状态（与下位机联机成功置1）16-0702
//    U8              mConnectCnt[MAX_NODE_NUM];  // 联机命令发送计数器 16-0718
    U8              mDataFormat[MAX_NODE_NUM];  // 下位机实时数据格式 16-0702

    U16             mCanOffCnt[MAX_NODE_NUM];   // CAN超时脱机计数器 15-1213
    strCanCtrl      mCanTxData[MAX_NODE_NUM];   // 实际送到CAN的数据（含并联分配数据） 15-1213
    strCanRxData    mCanRxData[MAX_NODE_NUM];   // 来自CAN的接收数据 15-1213

public:
    strNodeTbl      mNodeTbl;                   // 通道节点映射检索表

//函数
private:
    void    Initialization();

public:
    ParallelChan();

    U8      InitNodeTbl(void);                  // 初始化通道映射查找表 15-1212
    U8      LoadNodeTbl(void);                  // 加载通道映射查找表
    U8      SaveNodeTbl(U8 *ptr);               // 保存通道到电源单元（CAN地址-1）检索表
    U8      CheckNodeTbl(strNodeTbl *sptr);     // 检查通道与节点的映射表

    U8      GetConnectStat(U8);                 // 获取联机状态 16-0714

    U8      CanOffTest(U8 unit, S16 cnt);       // 单元脱机测试
    void    ClrCanData(U8 no);                  // 清下位机控制数据
    void    CanConnectTxProc(U8 unit, CAN_msg *msg);                // 发送下位机联机命令 16-0718
    void    CanTxProc(U8 unit, U8 f_no, U8 f_inx, CAN_msg *msg);    // 分发下位机控制数据
    void    CanRxProc(U8 unit, U8 cmd, S32 *S32data);               // 下位机主通道接收数据解析

    strCanCtrl  AllocCanData(strCanCtrl ctrldata);  // 动态分配下位机控制数据

};
//----------------------------------------------------------------------------------------------------
pchan_ext   ParallelChan    cParallelChan;

//----------------------------------------------------------------------------------------------------
#endif  // #ifdef   __cplusplus
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
#ifdef      __cplusplus
    extern "C" 
    {
#endif
//--------------------------------------------------
pchan_ext   void    Init_ParallelChan(void);


//--------------------------------------------------
#ifdef      __cplusplus
    }
#endif
//----------------------------------------------------------------------------------------------------
#endif
